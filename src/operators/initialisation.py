from math import floor
from random import shuffle, randint

from representation.tree import Tree, generate_tree
from algorithm.parameters import params
from representation import individual


def random_init(size):
    """
    Randomly create a population of size and return.

    :param size: The size of the required population.
    :return: A full population composed of randomly generated individuals.
    """

    return [individual.Individual(None, None) for _ in range(size)]


def generate_ind_tree(depth, method):
    """
    Generate an individual using a given subtree initialisation method.

    :param depth: The maximum depth for the initialised subtree.
    :param method: The method of subtree initialisation required.
    :return:
    """

    # Initialise an instance of the tree class
    ind_tree = Tree((str(params['BNF_GRAMMAR'].start_rule[0]),), None,
                max_depth=depth - 1, depth_limit=depth - 1)

    # Generate a tree
    genome, nodes, d, tree_depth = generate_tree(ind_tree, [], method,
                                                0, 0, 0, depth - 1)

    # Ensure the generated tree is valid (i.e. all non-terminals have been
    # fully expanded).
    if ind_tree.check_expansion():
        print("tree.init generated an Invalid")
        quit()

    # Get remaining individual information
    phenotype, invalid, used_cod = ind_tree.get_output(), False, len(genome)

    # Initialise individual
    ind = individual.Individual(genome, ind_tree, map=False)

    # Set individual parameters
    ind.phenotype, ind.nodes = phenotype, nodes
    ind.depth, ind.used_codons = tree_depth, used_cod
    ind.invalid = invalid

    # Generate random tail for genome.
    ind.genome = genome + [randint(0, params['CODON_SIZE']) for
                           _ in range(int(ind.used_codons / 2))]

    return ind


def rhh(size):
    """
    Create a population of size using ramped half and half (or sensible
    initialisation) and return.

    :param size: The size of the required population.
    :return: A full population of individuals.
    """

    # Calculate the range of depths to ramp individuals from.
    depths = range(params['BNF_GRAMMAR'].min_ramp + 1,
                   params['MAX_INIT_DEPTH']+1)
    population = []

    if size < 2:
        # If the population size is too small, can't use RHH initialisation.
        print("Error: population size too small for RHH initialisation.")
        print("Returning randomly built trees.")
        return [individual.Individual(None, None) for _ in range(size)]

    elif not depths:
        # If we have no depths to ramp from, then params['MAX_INIT_DEPTH'] is
        # set too low for the specified grammar.
        print("Error: Maximum initialisation depth too low for specified "
              "grammar.")
        quit()

    else:
        if size % 2:
            # Population size is odd, need an even population for RHH
            # initialisation.
            size += 1
            print("Warning: Specified population size is odd, "
                  "RHH initialisation requires an even population size. "
                  "Incrementing population size by 1.")

        if size/2 < len(depths):
            # The population size is too small to fully cover all ramping
            # depths. Only ramp to the number of depths we can reach.
            depths = depths[:int(size/2)]

        # Calculate how many individuals are to be generated by each
        # initialisation method.
        times = int(floor((size/2)/len(depths)))
        remainder = int(size/2 - (times * len(depths)))

        # Iterate over depths.
        for depth in depths:
            # Iterate over number of required individuals per depth.
            for i in range(times):

                # Generate individual using "Grow"
                ind = generate_ind_tree(depth, "random")

                # Append individual to population
                population.append(ind)

                # Generate individual using "Full"
                ind = generate_ind_tree(depth, "full")

                # Append individual to population
                population.append(ind)

        if remainder:
            # The full "size" individuals were not generated. The population
            #  will be completed with individuals of random depths.
            depths = list(depths)
            shuffle(depths)

        for i in range(remainder):
            depth = depths.pop()

            # Generate individual using "Grow"
            ind = generate_ind_tree(depth, "random")

            # Append individual to population
            population.append(ind)

            # Generate individual using "Full"
            ind = generate_ind_tree(depth, "full")

            # Append individual to population
            population.append(ind)

        return population


def get_min_ramp_depth(grammar):
    """
    Find the minimum depth at which ramping can start where we can have
    unique solutions (no duplicates).

    :param grammar: An instance of the representation.grammar.grammar class.
    :return: The minimum depth at which unuique solutions can be generated
    """

    max_tree_deth = params['MAX_TREE_DEPTH']
    size = params['POPULATION_SIZE']

    # Specify the range of ramping depths
    depths = range(grammar.min_path, max_tree_deth+1)

    if size % 2:
        # Population size is odd
        size += 1

    if size/2 < len(depths):
        # The population size is too small to fully cover all ramping
        # depths. Only ramp to the number of depths we can reach.
        depths = depths[:int(size/2)]

    # Find the minimum number of unique solutions required to generate
    # sufficient individuals at each depth.
    unique_start = int(floor(size/len(depths)))
    ramp = None

    for i in sorted(grammar.permutations.keys()):
        # Examine the number of permutations and combinations of unique
        # solutions capable of being generated by a grammar across each
        # depth i.
        if grammar.permutations[i] > unique_start:
            # If the number of permutations possible at a given depth i is
            # greater than the required number of unique solutions,
            # set the minimum ramp depth and break out of the loop.
            ramp = i
            break
    return ramp
